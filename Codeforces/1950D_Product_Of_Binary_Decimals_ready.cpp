/**
*  Generated by tpp tool
*  File: 1950D_Product_Of_Binary_Decimals.cpp
*  Created: 28-03-2024 12:30:00
**/

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <bitset>
#include <sstream>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <stack>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
using namespace std;



const int MAX = 1e5;
map<int, bool> M;
vector<pair<int,int>> V;

void dfs(int depht, int d, int val) {
  if(d > depht || val > MAX) return;

  M[val] = 1;
  if(val % 10) dfs(depht, d + 1, val * 10);
  else {
    dfs(depht, d, val + 1);
    dfs(depht, d + 1, val * 10);
  }
}

bool isPossible(int n) {
  int i = 1;

  while(i < V.size() && n != 1) {
    if(n/V[i].first > 0 && n % V[i].first == 0) n = n/V[i].first;
    else i++;
  }

  return n == 1;
}

int main() {
    // do not remove this code if you use cin or cout
    ios::sync_with_stdio(false);
    cin.tie(0);

    M[1] = 1;
    dfs(6, 2, 10);
    
    V = vector<pair<int,int>>(M.begin(), M.end());

    int t;
    cin>>t;

    while(t--) {
      int n;
      cin>>n;

      if(M[n]) cout<<"YES"<<endl;
      else {
        if(isPossible(n)) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
      }
    }

    return 0;
}

