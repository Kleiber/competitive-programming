/**
*  Generated by tpp tool
*  File: segment_tree_from_array.cpp
*  Created: 09-01-2024 13:59:15
**/

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <bitset>
#include <sstream>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <stack>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
using namespace std;


/*
 * Maximum number of elements in the array
*/
#define MAX 10005

/*
 * Convenient value to not affect the result when the answer is not found in the node segment
*/
#define INF 1000005 


// Array and segment tree
int A[MAX], tree[4*MAX];

/*
 * Build the tree structure that represents the segments.
 * - node is an identifier for the tree, the root would be node 1 
 * - [L, R] is the segment that represents the node  
*/
void build(int node, int L, int R) {
  // Base case, leaves have the value of each index in the array
  if(L == R) tree[node] = A[L];
  else {
    // Expand the build to childrens
    build(2*node, L, (L + R)/2);
    build(2*node + 1, (L + R)/2 + 1, R);

    // Compute the parent value
    tree[node] = min(tree[2*node], tree[2*node + 1]);
  }
}

/*
 * Consult the tree structure to answer queries.
 * - node is an identifier for the tree
 * - [L, R] is the segment that represents the node
 * - [l, r] is the segment of the requested query
*/
int query(int node, int L, int R, int l, int r) {
  /* 
   * Case where the node segment is completely outside the query segment
   * Therefore the value of the node does not contribute to the query
   *
   * 1) Query segment is to the right of the node segment
   *
   *    [L      R]
   *               [l      r]
   *
   * 
   * 2) Query segment is to the left of the node segment
   * 
   *               [L      R]
   *    [l      r]
   *
  */
  if(L > r || R < l) return INF;

  /*
   * Case where the node segment contains the query answer
   *
   * 1) Query segment is completely included in the node segment
   * 
   *    [L                 R]
   *        [l       r]
   *
   * 2) Query segment is the same as the node segment
   *
   *    [L                 R]
   *    [l                 r]
   *
  */
  if(L >= l && R <= r) return tree[node];

  /*
   * Case where the node segment contains a part of the query answer
   * We expand the exploration to both child nodes in the segment tree
   *
   *  1) First scenary
   *
   *    [L           R]
   *         [l            r]
   *
   *  2) Second scenary
   *
   *    [l           r]
   *         [L            R]  
   */
  int left  = query(2*node, L, (L + R)/2, l, r);
  int right = query(2*node + 1, (L + R)/2 + 1, R, l, r);

  // When we finish exploring the children
  // We calculate the return value for the parent
  return min(left, right);
}

int main() {
    // do not remove this code if you use cin or cout
    ios::sync_with_stdio(false);
    cin.tie(0);

    // Segment tree example to calculate the minimum value between ranges

    // Init
    memset(A, 0, sizeof(A));
    memset(tree, 0, sizeof(tree));

    // Array size
    int N = 7;

    // Init array A = [-1 0 -2 5 1 -9 3]
    A[0] = -1;
    A[1] = 0;
    A[2] = -2;
    A[3] = 5;
    A[4] = 1;
    A[5] = -9;
    A[6] = 3;

    // Build segment tree from root, using the array values
    build(1, 0, N - 1);

    // Print segment tree, have 13 nodes
    for(int i = 1; i < 14; i++) {
      cout<<"node: "<<i<<"  value: "<<tree[i]<<endl;
    }
    
    /*
     Output:
        node: 1  value: -9
        node: 2  value: -2
        node: 3  value: -9
        node: 4  value: -1
        node: 5  value: -2
        node: 6  value: -9
        node: 7  value: 3
        node: 8  value: -1
        node: 9  value: 0
        node: 10  value: -2
        node: 11  value: 5
        node: 12  value: 1
        node: 13  value: -9

     If we manually build the segment tree we can understand what this output means:
     
                  -9  (root)
             /          \
           -2            -9
          /   \        /     \
       -1      -2     -9      3
       / \    /  \    / \
     -1   0  -2   5  1  -9


      depth |          nodes
      -----------------------------
       #l   |           1
       #2   |      2          3
       #3   |   4    5     6     7
       #4   | 8  9 10 11 12 13

     */
 
    /*
      Queries in the original array

      Pos   1 2  3 4 5  6 7
           -----------------
      A = [-1 0 -2 5 1 -9 3]
    */
    
    // Query #1 : Min [1, 7] = -9
    cout<<"Query #1: "<<query(1, 0, N - 1, 0, 6)<<endl;

    // Query #2 : Min [1, 2] = -1
    cout<<"Query #2: "<<query(1, 0, N - 1, 0, 1)<<endl;

    // Query #3 : Min [3, 5] = -2
    cout<<"Query #3: "<<query(1, 0, N - 1, 2, 4)<<endl;

    return 0;
}