/**
*  Generated by tpp tool
*  File: segment_tree_with_lazy_propagation.cpp
*  Created: 10-01-2024 12:54:49
**/

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <bitset>
#include <sstream>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <stack>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
using namespace std;


/*
 * Maximum number of elements in the array
*/
#define MAX 10005

/*
 * Convenient value to not affect the result when the answer is not found in the node segment
*/
#define INF 1000005 


// Array, segment tree and lazy tree
int A[MAX], tree[4*MAX], lazy[4*MAX];

/*
 * Build the tree structure that represents the segments.
 * - node is an identifier for the tree, the root would be node 1 
 * - [L, R] is the segment that represents the node  
*/
void build(int node, int L, int R) {
  // Base case, leaves have the value of each index in the array
  if(L == R) tree[node] = A[L];
  else {
    // Expand the build to childrens
    build(2*node, L, (L + R)/2);
    build(2*node + 1, (L + R)/2 + 1, R);

    // Compute the parent value
    tree[node] = min(tree[2*node], tree[2*node + 1]);
  }
}

/*
 * Consult the tree structure to answer queries.
 * - node is an identifier for the tree
 * - [L, R] is the segment that represents the node
 * - [l, r] is the segment of the requested query
*/
int query(int node, int L, int R, int l, int r) {
  /* 
   * Case where the node segment is completely outside the query segment
   * Therefore the value of the node does not contribute to the query
   *
   * 1) Query segment is to the right of the node segment
   *
   *    [L      R]
   *               [l      r]
   *
   * 
   * 2) Query segment is to the left of the node segment
   * 
   *               [L      R]
   *    [l      r]
   *
  */
  if(L > r || R < l) return INF;

  /*
   * If there is something in the lazy tree, 
   * We apply the operation before doing the query 
   * To have the node's segment value updated
  */
  if(lazy[node] != 0) {
    tree[node] += lazy[node];

    /*
     * If the segment node is not a leaf (a value of the original array)
     * We propagate the operation to the children
    */
    if(L != R) {
      lazy[2*node] += lazy[node];
      lazy[2*node + 1] += lazy[node];
    }

    // We restart the node value in the lazy tree of the node that applies the operation
    lazy[node] = 0;
  }

  /*
   * Case where the node segment contains the query answer
   *
   * 1) Query segment is completely included in the node segment
   * 
   *    [L                 R]
   *        [l       r]
   *
   * 2) Query segment is the same as the node segment
   *
   *    [L                 R]
   *    [l                 r]
   *
  */
  if(L >= l && R <= r) return tree[node];

  /*
   * Case where the node segment contains a part of the query answer
   * We expand the exploration to both child nodes in the segment tree
   *
   *  1) First scenary
   *
   *    [L           R]
   *         [l            r]
   *
   *  2) Second scenary
   *
   *    [l           r]
   *         [L            R]  
   */
  int left  = query(2*node, L, (L + R)/2, l, r);
  int right = query(2*node + 1, (L + R)/2 + 1, R, l, r);

  // When we finish exploring the children
  // We calculate the return value for the parent
  return min(left, right);
}

/*
 * Update an element in the array i.e also update the segment tree
 * - node is an identifier for the tree
 * - [L, R] is the segment that represents the node
 * - ind is the index of the element to be updated, in other words it would be the segment [ind, ind] in the tree
 * - val is the new value that the element will take at the indicated index
*/
void update(int node, int L, int R, int l, int r, int val){
  /*
   * If there is something in the lazy tree, 
   * We apply the operation before doing the update 
   * To have the node's segment value updated
  */
  if(lazy[node] != 0) {
    tree[node] += lazy[node];

    /*
     * If the segment node is not a leaf (a value of the original array)
     * We propagate the operation to the children
    */
    if(L != R) {
      lazy[2*node] += lazy[node];
      lazy[2*node + 1] += lazy[node];
    }

    lazy[node] = 0;
  }

  // Element segment is outside the node segment
  if(L > r || R < l) return;

  /*
   * If the node segment is completely included in the query 
   * Then we update add the val parameter to the the segment node
  */
  if(L >= l && R <= r) {
    tree[node] += val;

    /*
     * If the segment node is not a leaf (a value of the original array)
     * We propagate the operation to the children
    */
    if(L != R){
      lazy[2*node] += val;
      lazy[2*node + 1] += val;
    }

    return;
  }
  
  // We expand the search to the children
  update(2*node, L, (L + R)/2, l, r, val);
  update(2*node + 1, (L + R)/2 + 1, R, l, r, val);
  
  // Once the search on the children has finished
  // We update the value of the parent
  tree[node] = min(tree[2*node], tree[2*node + 1]);
}

int main() {
    // do not remove this code if you use cin or cout
    ios::sync_with_stdio(false);
    cin.tie(0);

    // Segment tree example to calculate the minimum value between ranges
    // Includes updates in ranges (Lazy Propagation)

    // Init
    memset(A, 0, sizeof(A));
    memset(tree, 0, sizeof(tree));
    memset(lazy, 0, sizeof(lazy));

    // Array size
    int N = 7;

    // Init array A = [-1 0 -2 5 1 -9 3]
    A[0] = -1;
    A[1] = 0;
    A[2] = -2;
    A[3] = 5;
    A[4] = 1;
    A[5] = -9;
    A[6] = 3;

    // Build segment tree from root, using the array values
    build(1, 0, N - 1);

    for(int i = 1; i < 14; i++) {
        cout<<"tree node: "<<i<<"  value: "<<tree[i]<<endl;
    }
    for(int i = 1; i < 14; i++) {
        cout<<"lazy node: "<<i<<"  value: "<<lazy[i]<<endl;
    }
    
    /*
     * Output:
       tree node: 1  value: -9
        tree node: 2  value: -2
        tree node: 3  value: -9
        tree node: 4  value: -1
        tree node: 5  value: -2
        tree node: 6  value: -9
        tree node: 7  value: 3
        tree node: 8  value: -1
        tree node: 9  value: 0
        tree node: 10  value: -2
        tree node: 11  value: 5
        tree node: 12  value: 1
        tree node: 13  value: -9
        lazy node: 1  value: 0
        lazy node: 2  value: 0
        lazy node: 3  value: 0
        lazy node: 4  value: 0
        lazy node: 5  value: 0
        lazy node: 6  value: 0
        lazy node: 7  value: 0
        lazy node: 8  value: 0
        lazy node: 9  value: 0
        lazy node: 10  value: 0
        lazy node: 11  value: 0
        lazy node: 12  value: 0
        lazy node: 13  value: 0

     * That means that we already have the segment tree created and the propagation tree.
     
                  -9  (root)                         0  (lazy propagation tree)
             /          \                        /        \
           -2            -9                    0             0
          /   \        /     \              /    \         /    \
       -1      -2     -9      3            0      0       0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              0    0  0    0  0   0


      depth |          nodes
      -----------------------------
       #l   |           1
       #2   |      2          3
       #3   |   4    5     6     7
       #4   | 8  9 10 11 12 13

    */

    // Queries and Updates 

    /*
     * Query #1 : Min [1, 4] = -2

       Pos    1 2  3 4 5  6 7
            -----------------
        A = [-1 0 -2 5 1 -9 3]


                 -9  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            -2            -9                    0             0
          /   \        /     \              /    \         /    \
       -1      -2     -9      3            0      0       0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              0    0  0    0  0   0
    
    */
    cout<<"Query #1: "<<query(1, 0, N - 1, 0, 3)<<endl;

    /*
     * Update: Sum +3 to range [1, 4]

        Pos   1 2  3 4 5  6 7
            -----------------
        A = [-1 0 -2 5 1 -9 3]  (previous to update)
        A = [ 2 3  1 8 1 -9 3]  (updated)
     
     
                  -9  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            1            -9                    0             0
          /   \        /     \              /    \         /    \
       -1      -2     -9      3            3      3       0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              0    0  0    0  0   0
    
    */
    update(1, 0, N - 1, 0, 3, 3);

    /* 
     * Query #2 : Min [1, 4] = 1

        Pos   1 2  3 4 5  6 7
            -----------------
        A = [ 2 3  1 8 1 -9 3]

                  -9  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            1            -9                    0             0
          /   \        /     \              /    \         /    \
       -1      -2     -9      3            3      3       0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              0    0  0    0  0   0
    
    */
    cout<<"Query #2: "<<query(1, 0, N - 1, 0, 3)<<endl;

    /*
     * Update: Sum -1 to range [3, 7]

        Pos   1 2  3 4 5   6 7
            -----------------
        A = [ 2 3  1 8 1  -9 3]  (previous to update)
        A = [ 2 3  0 7 0 -10 2]  (updated)
     
     
                 -10  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            0            -10                    0             0
          /   \        /     \              /    \         /    \
        2      0     -9      3             0      0       -1    -1
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              3    3  2    2  0   0
    
    */
    update(1, 0, N - 1, 2, 6, -1);

    /* 
     * Query #2 : Min [1, 7] = -10

        Pos   1 2  3 4 5   6 7
            -----------------
        A = [ 2 3  0 7 0 -10 2]


                -10  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            0            -10                    0             0
          /   \        /     \              /    \         /    \
        2      0     -9      3             0      0       -1    -1
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  -2   5  1  -9              3    3  2    2  0   0

    */
    cout<<"Query #3: "<<query(1, 0, N - 1, 0, 6)<<endl;

    /*
     * Update: Sum +2 to range [4, 6]

        Pos   1 2  3 4 5   6 7
            -----------------
        A = [ 2 3  0 7 0 -10 2]  (previous to update)
        A = [ 2 3  0 9 2  -8 2]  (updated)
     
     
                 -8  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            0            -8                    0             0
          /   \        /     \              /    \         /    \
        2      0     -8       2             0      0      0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  0    9  1  -9              3    3  0    0  1   1

    */
    update(1, 0, N - 1, 3, 5, 2);

    /*
     * Query #2 : Min [1, 7] = -8

        Pos   1 2  3 4 5   6 7
            -----------------
        A = [ 2 3  0 9 2  -8 2]
         
        
                 -8  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            0            -8                    0             0
          /   \        /     \              /    \         /    \
        2      0     -8       2             0      0      0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   0  0    9  1  -9              3    3  0    0  1   1

    */
    cout<<"Query #4: "<<query(1, 0, N - 1, 0, 6)<<endl;

    /*
     * Query #2 : Min [2, 5] = 0

        Pos   1 2  3 4 5   6 7
            -----------------
        A = [ 2 3  0 9 2  -8 2]

                 -8  (root)                         0  (lazy propagation tree)
             /          \                        /        \
            0            -8                    0             0
          /   \        /     \              /    \         /    \
        2      0     -8       2             0      0      0      0
       / \    /  \    / \                /  \    /  \    / \    
     -1   3  0    9  2  -9              3    0  0    0  0   1

    */
    cout<<"Query #5: "<<query(1, 0, N - 1, 1, 4)<<endl;

    return 0;
}