/**
*  Generated by tpp tool
*  File: segment_tree_with_array_element_update.cpp
*  Created: 10-01-2024 12:19:55
**/

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <bitset>
#include <sstream>
#include <set>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <stack>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
using namespace std;


/*
 * Maximum number of elements in the array
*/
#define MAX 10005

/*
 * Convenient value to not affect the result when the answer is not found in the node segment
*/
#define INF 1000005 


// Array and segment tree
int A[MAX], tree[4*MAX];

/*
 * Build the tree structure that represents the segments.
 * - node is an identifier for the tree, the root would be node 1 
 * - [L, R] is the segment that represents the node  
*/
void build(int node, int L, int R) {
  // Base case, leaves have the value of each index in the array
  if(L == R) tree[node] = A[L];
  else {
    // Expand the build to childrens
    build(2*node, L, (L + R)/2);
    build(2*node + 1, (L + R)/2 + 1, R);

    // Compute the parent value
    tree[node] = min(tree[2*node], tree[2*node + 1]);
  }
}

/*
 * Consult the tree structure to answer queries.
 * - node is an identifier for the tree
 * - [L, R] is the segment that represents the node
 * - [l, r] is the segment of the requested query
*/
int query(int node, int L, int R, int l, int r) {
  /* 
   * Case where the node segment is completely outside the query segment
   * Therefore the value of the node does not contribute to the query
   *
   * 1) Query segment is to the right of the node segment
   *
   *    [L      R]
   *               [l      r]
   *
   * 
   * 2) Query segment is to the left of the node segment
   * 
   *               [L      R]
   *    [l      r]
   *
  */
  if(L > r || R < l) return INF;

  /*
   * Case where the node segment contains the query answer
   *
   * 1) Query segment is completely included in the node segment
   * 
   *    [L                 R]
   *        [l       r]
   *
   * 2) Query segment is the same as the node segment
   *
   *    [L                 R]
   *    [l                 r]
   *
  */
  if(L >= l && R <= r) return tree[node];

  /*
   * Case where the node segment contains a part of the query answer
   * We expand the exploration to both child nodes in the segment tree
   *
   *  1) First scenary
   *
   *    [L           R]
   *         [l            r]
   *
   *  2) Second scenary
   *
   *    [l           r]
   *         [L            R]  
   */
  int left  = query(2*node, L, (L + R)/2, l, r);
  int right = query(2*node + 1, (L + R)/2 + 1, R, l, r);

  // When we finish exploring the children
  // We calculate the return value for the parent
  return min(left, right);
}

/*
 * Update an element in the array i.e also update the segment tree
 * - node is an identifier for the tree
 * - [L, R] is the segment that represents the node
 * - ind is the index of the element to be updated, in other words it would be the segment [ind, ind] in the tree
 * - val is the new value that the element will take at the indicated index
*/
void update(int node, int L, int R, int ind, int val){
  // Element segment is outside the node segment
  if(L > ind || R < ind) return;
  
  // Otherwise, the element will be within the segment 
  // And if the segment limits are equal [L, L] or [R, R]
  // It is the desired segment (array element in the leaf)
  if(L == R) tree[node] = val;
  else{
    // We expand the search to the children
    update(2*node, L, (L + R)/2, ind, val);
    update(2*node + 1, (L + R)/2 + 1, R, ind, val);

    // Once the search on the children has finished
    // We update the value of the parent
    tree[node] = min(tree[2*node], tree[2*node + 1]);
  }
}

int main() {
    // do not remove this code if you use cin or cout
    ios::sync_with_stdio(false);
    cin.tie(0);

    // Segment tree example to calculate the minimum value between ranges

    // Init
    memset(A, 0, sizeof(A));
    memset(tree, 0, sizeof(tree));

    // Array size
    int N = 7;

    // Init empty array A = [0 0 0 0 0 0 0]
    // Build segment tree from root, using the array values
    /*
                 0  (root)
              /       \
            0           0
          /   \        /   \
        0      0      0     0
       / \    /  \    / \
      0   0  0    0  0   0

    */
    build(1, 0, N - 1);

    // We can update some element in the array
    // This means that the segment tree will be updated

    /*
     * Update: element #3 with -1

        Pos   1 2  3 4 5 6 7
            -----------------
        A = [ 0 0 -1 0 0 0 0]


                 -1  (root)
              /       \
            -1          0
          /   \        /   \
        0      -1      0     0
       / \    /  \    / \
      0   0  0   -1  0   0

    */
    update(1, 0, N - 1, 2, -1);
    
    // Query #1 : Min [1, 7] = -1
    cout<<"Query #1: "<<query(1, 0, N - 1, 0, 6)<<endl;

    /*
     * Update: element #7 with -9

        Pos   1 2  3 4 5 6  7
            -----------------
        A = [ 0 0 -1 0 0 0 -9]


                 -9  (root)
              /       \
            -1          -9
          /   \        /   \
        0      -1      0    -9
       / \    /  \    / \
      0   0  -1   0  0   0

    */
    update(1, 0, N - 1, 6, -9);

    // Query #1 : Min [1, 7] = -9
    cout<<"Query #2: "<<query(1, 0, N - 1, 0, 6)<<endl;

    /*
     * Update: element #5 with -2

        Pos   1 2  3 4  5 6  7
            -----------------
        A = [ 0 0 -1 0 -2 0 -9]


                 -9  (root)
              /       \
            -1          -9
          /   \        /   \
        0      -1     -2    -9
       / \    /  \    / \
      0   0  -1   0 -2   0

    */
    update(1, 0, N - 1, 4, -2);

    // Query #1 : Min [4, 6] = -2
    cout<<"Query #3: "<<query(1, 0, N - 1, 3, 5)<<endl;

    return 0;
}
